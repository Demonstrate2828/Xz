<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Гениальное предсказание кликов</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f3f4f6;
      text-align: center;
      padding: 50px;
    }
    .container {
      position: relative;
      width: 100%;
      height: 500px;
      background-color: #e0e0e0;
      border: 2px solid #333;
    }
    .dot {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: red;
      border-radius: 50%;
    }
    .prediction {
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <h1>Гениальное предсказание кликов с нейросетью</h1>
  <p>Нажмите на области внутри контейнера, и нейросеть предскажет следующее место клика.</p>

  <div class="container" id="clickArea"></div>

  <div class="prediction">
    <h2>Предсказание клика:</h2>
    <p id="predictionOutput">Клик еще не был сделан</p>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <script>
    // Модель и переменные
    let model;
    let clicks = [];
    let nextPrediction = [0, 0]; // Начальное предсказание для первых кликов

    // Функция для создания модели с глубокой LSTM
    async function createAdvancedModel() {
      const model = tf.sequential();

      // Сложная архитектура LSTM
      model.add(tf.layers.lstm({
        units: 128,
        inputShape: [10, 6], // Используем данные о X, Y, скорости и времени
        activation: 'tanh',
        returnSequences: true
      }));

      model.add(tf.layers.lstm({
        units: 64,
        activation: 'tanh',
        returnSequences: false
      }));

      model.add(tf.layers.dense({
        units: 2, // Выход: предсказание X и Y
        activation: 'linear'
      }));

      model.compile({
        optimizer: tf.train.adam(0.001),
        loss: 'meanSquaredError'
      });

      return model;
    }

    // Функция для добавления данных кликов (с учетом скорости)
    function addClickData(x, y, speed, time) {
      clicks.push([x, y, speed, time]); // x, y, скорость, время
      if (clicks.length > 200) clicks.shift(); // Ограничиваем количество данных
    }

    // Функция для предсказания следующего клика
    async function predictNextClick() {
      if (clicks.length < 10) {
        document.getElementById('predictionOutput').innerText = "Недостаточно данных для предсказания";
        return;
      }

      // Предсказание на основе последних кликов
      const input = tf.tensor([clicks.slice(-10)]); // Используем последние 10 кликов
      const prediction = await model.predict(input).array();
      nextPrediction = prediction[0];

      document.getElementById('predictionOutput').innerText = `Предсказание: X = ${nextPrediction[0].toFixed(2)}, Y = ${nextPrediction[1].toFixed(2)}`;
      
      // Отображаем предсказание на экране
      const predictionDot = document.createElement('div');
      predictionDot.classList.add('dot');
      predictionDot.style.left = `${nextPrediction[0]}%`;
      predictionDot.style.top = `${nextPrediction[1]}%`;
      document.getElementById('clickArea').appendChild(predictionDot);
    }

    // Обработчик кликов
    document.getElementById('clickArea').addEventListener('click', (e) => {
      const rect = e.target.getBoundingClientRect();
      const x = (e.clientX - rect.left) / rect.width * 100;
      const y = (e.clientY - rect.top) / rect.height * 100;
      const time = new Date().getTime();

      // Считывание скорости движения мыши (опционально)
      const lastClick = clicks[clicks.length - 1];
      const speed = lastClick ? Math.sqrt(Math.pow(x - lastClick[0], 2) + Math.pow(y - lastClick[1], 2)) : 0;

      // Отображаем клик
      const dot = document.createElement('div');
      dot.classList.add('dot');
      dot.style.left = `${x}%`;
      dot.style.top = `${y}%`;
      document.getElementById('clickArea').appendChild(dot);

      // Добавляем данные для обучения
      addClickData(x, y, speed, time);

      // Обучаем модель в реальном времени
      if (clicks.length > 10) {
        const data = tf.tensor([clicks.slice(-10)]);
        const labels = tf.tensor([[[x, y]]]);

        model.fit(data, labels, {
          epochs: 1,
          batchSize: 1,
          shuffle: true
        }).then(() => {
          console.log("Модель обновлена!");
        });
      }

      // Обновляем предсказание
      predictNextClick();
    });

    // Инициализация модели
    (async function() {
      model = await createAdvancedModel();
      console.log("Модель загружена!");
    })();
  </script>
</body>
</html>
